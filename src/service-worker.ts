/// <reference lib="webworker" />
/* eslint-disable no-restricted-globals */

import { clientsClaim } from "workbox-core";
import { ExpirationPlugin } from "workbox-expiration";
import { precacheAndRoute, createHandlerBoundToURL } from "workbox-precaching";
import { registerRoute } from "workbox-routing";
import { NetworkFirst, NetworkOnly } from "workbox-strategies";
import { BackgroundSyncPlugin } from "workbox-background-sync";

declare const self: ServiceWorkerGlobalScope;

clientsClaim();

// Precache all of the assets generated by your build process.
precacheAndRoute(self.__WB_MANIFEST);

// App Shell-style routing, fulfilled with index.html.
const fileExtensionRegexp = new RegExp("/[^/?]+\\.[^/]+$");
registerRoute(({ request, url }: { request: Request; url: URL }) => {
  if (request.mode !== "navigate") {
    return false;
  }
  if (url.pathname.startsWith("/_")) {
    return false;
  }
  if (url.pathname.match(fileExtensionRegexp)) {
    return false;
  }
  return true;
}, createHandlerBoundToURL(process.env.PUBLIC_URL + "/index.html"));

// Network-first strategy for HTML files.
registerRoute(
  ({ request }) => request.destination === "document",
  new NetworkFirst({
    cacheName: "documents-cache",
    plugins: [new ExpirationPlugin({ maxEntries: 50 })],
  })
);

// Network-first strategy for CSS and JS files.
registerRoute(
  ({ request }) =>
    request.destination === "style" || request.destination === "script",
  new NetworkFirst({
    cacheName: "static-resources-cache",
    plugins: [new ExpirationPlugin({ maxEntries: 50 })],
  })
);

// Network-first strategy for images.
registerRoute(
  ({ request }) => request.destination === "image",
  new NetworkFirst({
    cacheName: "images-cache",
    plugins: [new ExpirationPlugin({ maxEntries: 50 })],
  })
);

// Array of API URLs to be cached.
const apiUrls = [
  "http://localhost:3001/users",
  "https://fakestoreapi.com/products",
];

// Network-first strategy for the specified API requests with a fallback to cache-first.
registerRoute(
  ({ url }) => apiUrls.some((apiUrl) => url.href.startsWith(apiUrl)),
  async ({ request }) => {
    const cache = await caches.open("api-responses-cache");
    try {
      const networkResponse = await fetch(request);
      await cache.put(request, networkResponse.clone());
      return networkResponse;
    } catch (error) {
      const cachedResponse = await cache.match(request);
      if (cachedResponse) {
        return cachedResponse;
      }
      throw error;
    }
  }
);

const bgSyncPlugin = new BackgroundSyncPlugin("addUserQueue", {
  maxRetentionTime: 24 * 60, // Retry for max of 24 Hours (specified in minutes)
  onSync: async ({ queue }) => {
    let entry;
    while ((entry = await queue.shiftRequest())) {
      try {
        console.log("Attempting to reply request", entry.request);
        await fetch(entry.request);
        console.log("Reply succeeded for request", entry.request);

        //Notify all clients that sync is complete
        self.clients.matchAll({ type: "window" }).then((clients) => {
          clients.forEach((client) => {
            client.postMessage({ type: "SYNC_COMPLETE" });
          });
        });
      } catch (error) {
        console.error("Reply failed for request", entry.request, error);
        await queue.unshiftRequest(entry);
        throw error;
      }
    }
  },
});

registerRoute(
  ({ url, request }) => {
    return (
      url.href === `http://localhost:3001/users` && request.method === "POST"
    );
  },
  new NetworkOnly({
    plugins: [bgSyncPlugin],
  }),
  "POST"
);
// Skip waiting for the new service worker to activate immediately.
self.addEventListener("message", (event) => {
  if (event.data && event.data.type === "SKIP_WAITING") {
    self.skipWaiting();
  }
});

self.addEventListener("sync", (event) => {
  console.log("Sync event triggered", event);
  if (event.tag === "addUserQueue") {
    console.log("Sync event: addUserQueue");
  }
});
